"" 
Software
Design and Implementation
Week 09 

หัวข้อที่จะศึกษา
*	Object-oriented design using the UML
*	Design patterns
*	Implementation issues
*	Open source development 
Design and implementation
*	การออกแบบและสร้างซอฟต์แวร์เป็นขั้นตอนหนึ่งในกระบวนการวิศวกรรมซอฟต์แวร์
*	เป็นกระบวนการที่ทำให้เกิดซอฟต์แวร์ที่ใช้งานได้จริง (executable software) ขึ้นมา
*	การออกแบบและการสร้างซอฟต์แวร์เป็นกระบวนการที่ต้องดำเนินการควบคู่กันเสมอ
*	การออกแบบซอฟต์แวร์ (software design) เป็นกิจกรรมที่สร้างสรรค์ หมายความว่าต้องสร้างสิ่งที่ยังไม่มีอยู่
*	เราต้องสร้างส่วนประกอบซอฟต์แวร์และจัดการความสัมพันธ์ของส่วนประกอบเหล่านั้น ตามความต้องการของลูกค้า
*	การดำเนินการสร้างซอฟต์แวร์ (software implementation) เป็นกระบวนการทำให้ แบบกลายเป็นโปรแกรม
*	ต้องใช้ความสามารถด้านการ programming
Build or buy
*	โดส่วนใหญ่แล้ว ในหลาย ๆ โดเมนเราสามารถซื้อระบบที่พัฒนาเสร็จแล้วที่สามารถปรับแต่งตามความต้องการของผู้ใช้
*	ตัวอย่างเช่น ถ้าลูกค้าต้องการใช้ระบบเวชระเบียนในโรงพยาบาล เราสามารถซื้อแพคเกจที่ใช้ในโรงพยาบาลอื่น ๆ มาดัดแปลง
*	อาจจะถูกกว่าและเร็วกว่าที่จะพัฒนาระบบขึ้นมาใหม่ทั้งหมด
*	ถ้าเราเลือกวิธีการพัฒนาในลักษณะนี้ งาน implementation จะเทไปทางด้าน configuration management แทนที่จะเป็น programming
*	การเก็บ requirement ก็อาจจะต่างออกไป
Object-oriented design using the UML
An object-oriented design process
*	กระบวนการออกแบบเชิงวัตถุ มีโมเดลต่าง ๆ ให้ใช้งานจำนวนมาก
*	ในการพัฒนาและบำรุงรักษาโมเดลเหล่านั้นจะต้องใช้ความพยายามและทรัพยากรเป็นจำนวนมาก
*	อาจไม่คุ้มค่าสำหรับระบบขนาดเล็ก ๆ 
*	สำหรับระบบขนาดใหญ่ที่พัฒนาขึ้นโดยกลุ่มคนจำนวนมาก  การออกแบบโมเดลถือเป็นกลไกการสื่อสารที่สำคัญ ที่จะนำไปสู่ความสำเร็จ
Process stages
*	ในการออกแบบระบบ มีกระบวนการที่แตกต่างกันหลายรูปแบบ ขึ้นอยู่กับวัตถุประสงค์ของงาน 
*	โดยทั่วไป กิจกรรมในกระบวนการจะประกอบด้วย
*	การกำหนดบริบทและรูปแบบการใช้งานระบบ
*	การออกแบบสถาปัตยกรรมระบบ
*	การระบุวัตถุหลักในระบบ
*	การออกแบบและพัฒนาแบบจำลอง
*	การกดำหนดการเชื่อมโยงความสัมพันธ์ระหว่างวัตถุในระบบ

System context and interactions
*	ทำความเข้าใจความสัมพันธ์ระหว่างซอฟต์แวร์ที่ออกแบบและสภาพแวดล้อมภายนอก
*	เป็นสิ่งสำคัญสำหรับการตัดสินใจว่าจะสร้างระบบที่มีการทำงานอย่างไร
*	สามารถกำหนดวิธีจัดโครงสร้างระบบเพื่อสื่อสารกับสภาพแวดล้อม
*	ทำความเข้าใจบริบทของระบบ
*	ช่วยให้สามารถกำหนดขอบเขตของระบบ 
*	ช่วยให้ตัดสินใจได้ว่า จะบรรจุคุณลักษณะใดในระบบที่ออกแบบและใช้งานคุณลักษณะใดจากระบบอื่นที่เกี่ยวข้อง
Context and interaction models
*	แบบจำลองบริบทของระบบ (context model) 
*	เป็นแบบจำลองโครงสร้างที่แสดงให้เห็นถึงระบบอื่น ๆ ที่อยู่ในสภาพแวดล้อมของระบบที่พัฒนา
*	แบบจำลองการโต้ตอบ (interaction model) 
*	เป็นแบบจำลองไดนามิก ที่แสดงให้เห็นว่าระบบมีปฏิสัมพันธ์กับสภาพแวดล้อมในขณะต่าง ๆ อย่างไร
System context for the weather station 
Weather station use cases 
Use case description—Report weather 
Architectural design
*	เมื่อเข้าใจปฏิสัมพันธ์ระหว่างระบบกับสิ่งแวดล้อมแล้ว เราสามารถใช้ข้อมูลนี้ในการออกแบบสถาปัตยกรรมระบบ
*	เริ่มจากการระบุส่วนประกอบสำคัญ ๆ ที่ประกอบกันเป็นส่วนหนึ่งของระบบและปฏิสัมพันธ์ของพวกมัน
*	จากนั้นอาจจัดองค์ประกอบต่าง ๆ โดยใช้รูปแบบสถาปัตยกรรมที่เป็นมาตรฐาน เช่น แบบเลเยอร์ (layer) หรือ แบบไคลเอ็นต์เซิร์ฟเวอร์ (client-server)
*	สถานีอากาศประกอบด้วยระบบย่อยอิสระ ที่สื่อสารโดยการส่งข้อความ (message broadcasting)
High-level architecture of the weather station 
Architecture of data collection system 
Object class identification
*	การระบุ object class มักเป็นส่วนที่ยากในการออกแบบเชิงวัตถุ
*	ไม่มี 'สูตรสำเร็จ' สำหรับการออกแบบวัตถุ มันขึ้นอยู่กับทักษะประสบการณ์และความรู้เกี่ยวกับโดเมนของนักออกแบบระบบ
*	การระบุวัตถุเป็นกระบวนการซ้ำซ้อน ที่ต้องทำซ้ำจนกว่าจะเป็นที่น่าพอใจ
*	ไม่มีใครที่จะทำได้สำเร็จอย่างงดงามได้ในครั้งแรก หรือเพียงรอบเดียว
Approaches to identification
*	อธิบายระบบ โดยใช้วิธีการทางไวยากรณ์ตามภาษาธรรมชาติ
*	อธิบายวัตถุ โดยใช้สิ่งที่จับต้องได้ในโดเมนเป็นจุดอ้างอิง
*	อธิบายพฤติกรรม ระบุวัตถุตามการมีส่วนร่วมในพฤติกรรมนั้น 
*	วิเคราะห์สถานการณ์ แล้วระบุ object, attribute และ method ตามแต่ละสถานการณ์
Weather station object classes
*	การระบุ object class ในระบบสถานีวัดอากาศอาจพิจารณาจากฮาร์ดแวร์ที่จับต้องได้รวมทั้งข้อมูลในระบบ เช่น
*	เครื่องวัดอุณหภูมิภาคพื้นดิน, เครื่องวัดความเร็วลม, บารอมิเตอร์
*	เป็นวัตถุของโดเมนแอ็พพลิเคชันซึ่งเป็น "ฮาร์ดแวร์" ที่เกี่ยวข้องกับเครื่องมือในระบบ
*	สถานีอากาศ
*	ประกอบด้วยส่วนติดต่อพื้นฐานของสถานีอากาศกับสภาพแวดล้อม ดังการโต้ตอบที่ระบุไว้ในแบบจำลอง use case
*	ข้อมูลสภาพอากาศ
*	ประกอบด้วยข้อมูลจากเครื่องมือวัดต่าง ๆ 
Weather station object classes 
Design models
*	design model แสดง object และ object class รวมทั้งความสัมพันธ์ระหว่างสิ่งเหล่านั้น
*	design model  มีสองรูปแบบ ได้แก่
*	โมเดลแบบโครงสร้าง อธิบายถึงโครงสร้างแบบคงที่ของระบบในแง่ของคลาสวัตถุและความสัมพันธ์
*	โมเดลแบบไดนามิก อธิบายปฏิสัมพันธ์แบบไดนามิกระหว่างวัตถุ
Examples of design models
*	แบบจำลองระบบย่อยที่แสดงการจัดกลุ่มของ object ในระบบ (subsystem model)
*	แบบจำลองแสดงลำดับของการโต้ตอบของวัตถุ (sequence model)
*	แบบจำลองที่แสดงให้เห็นว่า object เปลี่ยนสถานะอย่างไรเพื่อตอบสนองต่อเหตุการณ์ (State machine models) 
*	แบบจำลองอื่น ๆ เช่น use-case models, aggregation models, generalisation models, เป็นต้น
Subsystem models
*	แสดงการจัดวางระบบโดยให้ object ที่เกี่ยวข้องกันอยู่รวมกันอย่างเป็นหมวดหมู่
*	ใน UML วัตถุเหล่านี้จะแสดงรวมกันเป็นแพคเกจ (package) โดยมีแนวคิด encapsulation เป็นสำคญ
*	แบบจำลองนี้จะเป็นเชิงตรรกะ
*	ในการจัดองค์ประกอบที่แท้จริงของวัตถุในแต่ละระบบอาจแตกต่างกัน
Sequence models
*	แสดงลำดับการโต้ตอบของอ็อบเจ็กต์ที่เกิดขึ้นตามเวลา
*	วัตถุเรียงตามแนวนอนอยู่ด้านบน
*	เวลาจะแสดงในแนวตั้ง แสดงลำดับเหตุการณ์จากบนลงล่าง
*	ปฏิสัมพันธ์แสดงด้วยลูกศรที่มีป้ายกำกับ
*	ลูกศรที่มีรูปแบบแตกต่างกัน แสดงถึงปฏิสัมพันธ์ที่แตกต่างกัน
*	รูปสี่เหลี่ยมผืนผ้าบาง ๆ ในเส้นชีวิตของวัตถุ แสดงถึงระยะเวลาที่วัตถุเป็นตัวควบคุมในระบบ
Sequence diagram describing data collection 
State diagrams
*	แผนผังสถานะ (state diagram) ใช้เพื่อ
*	แสดงวิธีที่วัตถุตอบสนองต่อคำขอบริการต่าง ๆ
*	การเปลี่ยนสถานะที่เรียกใช้โดยคำขอเหล่านั้น
*	แผนผังสถานะเป็นโมเดลระดับสูง
*	แสดงพฤติกรรมในขณะทำงานของวัตถุ
*	ไม่จำเป็นต้องมีแผนภาพ state diagram สำหรับ object ทั้งหมดในระบบ 
*	Object จำนวนมากในระบบมีความเรียบง่าย
*	แบบจำลอง state diagram จะเพิ่มรายละเอียดที่ไม่จำเป็นให้กับการออกแบบ
Weather station state diagram 
Design patterns
Design patterns
*	Design pattern เป็นวิธีการ reuse ความรู้เชิงนามธรรมเกี่ยวกับปัญหาและแนวทางแก้ไข
*	Pattern คือคำอธิบายของปัญหาและสาระสำคัญของการแก้ปัญหา
*	Pattern เป็นนามธรรมเพียงพอที่จะนำมาใช้ซ้ำ โดยปรับแต่งเล็ก ๆ น้อย ๆ
*	Pattern descriptions มักใช้ประโยชน์จากลักษณะเชิงวัตถุ เช่น inheritance และ polymorphism
Pattern elements
*	Name
*	Identifier ของ pattern ที่สื่อความหมายชัดเจน
*	Problem description.
*	Solution description.
*	ไม่ใช่การออกแบบที่เป็นรูปธรรม 
*	เป็นเพียงเทมเพลตสำหรับการออกแบบที่สามารถปรับใช้งานได้ในรูปแบบต่าง ๆ
*	Consequences
*	ผลกระทบและเงื่อนไขในการตัดสินใจใช้ pattern นั้น ๆ
The Observer pattern
*	Name
*	Observer.
*	Description
*	แยกการแสดงสถานะของ object ออกจาก ตัว object
*	Problem description
*	ใช้เมื่อจำเป็นต้องแสดงสถานะของ state ได้หลายสถานะ 
*	Solution description
*	ดูสไลด์หน้าถัดไป
*	Consequences
*	การ Optimisations เพื่อเพิ่ม performance ในการแดงผลอาจทำได้ยาก
The Observer pattern (1) 
The Observer pattern (2) 
Multiple displays using the Observer pattern 
A UML model of the Observer pattern 
Design problems
*	หากต้องการใช้ design pattern ต้องแน่ใจว่าปัญหาด้านการออกแบบที่เรากำลังเจอ 
*	มี pattern ที่เกี่ยวข้องซึ่งสามารถนำมาใช้ได้ เช่น
*	บอก object ต่าง ๆ ว่า object หนึ่งมีการเปลี่ยนแปลงสถานะ (Observer pattern)
*	จัดระเบียบส่วนติดต่อกับ object  ที่ได้รับการพัฒนาแบบ incremental   (Façade pattern)
*	จัดเตรียมวิธีการมาตรฐานในการเข้าถึง element ในคอลเล็กชัน โดยไม่คำนึงถึงว่าคอลเล็กชันดังกล่าวมีการสร้างอย่างไร (Iterator pattern)
*	อนุญาตให้มีการขยายฟังก์ชันการทำงานของคลาสที่มีอยู่ในขณะทำงาน (run-time) (Decorator pattern)
Implementation issues
Implementation issues
*	การ implement ในที่นี้ ไม่ได้หมายถึงการเขียนโปรแกรม (แม้ว่าการเขียนโปรแกรมจะเป็นสิ่งสำคัญอย่างชัดเจน) แต่ยังมีประเด็นการใช้งานอื่น ๆ ที่มักไม่ครอบคลุมในตำราการเขียนโปรแกรม เช่น
*	Reuse ซอฟต์แวร์ที่ทันสมัยที่สุดในปัจจุบัน ถูกสร้างขึ้นโดยนำส่วนประกอบหรือระบบที่มีอยู่เดิมมาใช้ใหม่ 
*	เมื่อต้องการพัฒนาซอฟต์แวร์ ควรใช้ code ที่มีอยู่ให้มากที่สุดเท่าที่จะเป็นไปได้
*	Configuration management ในระหว่างขั้นตอนการพัฒนา จะมีหลาย ๆ  เวอร์ชันของส่วนประกอบซอฟต์แวร์แต่ละตัวในระบบที่ต้องคอยจัดการการกำหนดค่า
*	Host-target development – เป้าหมายในการผลิตซอฟต์แวร์มักไม่ใช้คอมพิวเตอร์เครื่องเดียวกับสภาพแวดล้อมในการพัฒนาซอฟต์แวร์ โดยส่วนใหญ่มักจะมีการพัฒนาบนคอมพิวเตอร์เครื่องหนึ่ง (ระบบโฮสต์) และรันบนคอมพิวเตอร์เครื่องหนึ่ง (ระบบเป้าหมาย)
Reuse
*	จากทศวรรษที่ 1960 ถึง 1990 ซอฟท์แวร์ใหม่ ๆ ได้รับการพัฒนาตั้งแต่เริ่มต้น (กระดาษเปล่า) โดยการเขียนโค้ดทั้งหมดในภาษาโปรแกรมระดับสูง
*	มีการ reuse ที่สำคัญเพียงอย่างเดียวคือการใช้ฟังก์ชันและไลบรารี
*	วิธีนี้ดูเหมือนจะไม่สามารถใช้งานได้มากขึ้นเรื่อย ๆ
*	โดยเฉพาะอย่างยิ่งสำหรับระบบเชิงพาณิชย์และอินเทอร์เน็ต
*	แรงกดดันที่สำคัญคือ ค่าใช้จ่ายและเวลาที่จะวางตลาด
*	การพัฒนาซอฟต์แวร์โดยอาศัยการ reuse นั้นมีอยู่และเกิดขึ้นมานานแล้วสำหรับซอฟต์แวร์ทางธุรกิจและวิทยาศาสตร์
Reuse levels
*	The abstraction level 
*	ในระดับนี้เราไม่ได้ reuse ซอฟต์แวร์โดยตรง แต่ใช้ความรู้เกี่ยวกับการออกแบบซอฟต์แวร์ที่ประสบความสำเร็จ
*	The object level 
*	ในระดับนี้ เรานำวัตถุมาใช้ใหม่จากไลบรารีโดยตรงแทนที่จะเขียนโค้ดด้วยตัวเอง
*	The component level 
*	component คือชุดของ objects และ classes ที่นำมาใช้ใหม่ใน application systems
*	The system level 
*	ในระดับนี้เราจะ reuse ระบบแอ็พพลิเคชันทั้งหมด

Software reuse
Reuse costs
*	ต้นทุนจากเวลาที่ใช้ในการมองหาซอฟต์แวร์เพื่อ reuse และประเมินว่าเป็นไปตามความต้องการหรือไม่
*	ค่าใช้จ่ายในการซื้อซอฟต์แวร์ที่สามารถ reuse ได้ 
*	สำหรับระบบ COTS (commercial of the shelf) ขนาดใหญ่ อาจมีค่าใช้จ่ายนี้ที่สูงมาก
*	ค่าใช้จ่ายในการปรับ (adapt) และกำหนดค่า (configuring) ส่วนประกอบหรือระบบซอฟต์แวร์ที่นำมา reuse ให้ตรงกับความต้องการของระบบที่กำลังพัฒนา
*	ค่าใช้จ่ายในการรวม (integrating) ส่วนประกอบซอฟต์แวร์ที่นำมา reuse 
*	ถ้าใช้ซอฟต์แวร์จากแหล่งต่าง ๆ ร่วมกับรหัสใหม่ที่เราพัฒนาขึ้น
Configuration management
*	Configuration management คือชื่อที่กำหนดให้กับกระบวนการทั่วไปในการจัดการการเปลี่ยนแปลงซอฟต์แวร์ 
*	จุดมุ่งหมายของ Configuration management คือการสนับสนุนกระบวนการรวมระบบ
*	เพื่อให้นักพัฒนาซอฟต์แวร์ทุกคนสามารถเข้าถึงรหัสโครงการและเอกสาร
*	เพื่อให้นักพัฒนาซอฟต์แวร์ตรวจสอบว่ามีการเปลี่ยนแปลงอะไรบ้าง
*	เพื่อให้นักพัฒนาซอฟต์แวร์คอมไพล์และเชื่อมโยงองค์ประกอบเพื่อสร้างระบบ
Configuration management activities
*	Version management 
*	สามารถติดตามส่วนประกอบของซอฟต์แวร์เวอร์ชันต่างๆ 
*	ระบบการจัดการเวอร์ชัน ประกอบด้วยสิ่งอำนวยความสะดวกในการร่วมพัฒนาโดยโปรแกรมเมอร์หลาย ๆ คน
*	System integration 
*	ช่วยให้นักพัฒนาสามารถกำหนดรุ่นของส่วนประกอบที่จะใช้ในการสร้างแต่ละรุ่นของระบบ
*	ใช้เพื่อสร้างระบบโดยอัตโนมัติ โดยการรวบรวมและเชื่อมโยงส่วนประกอบที่จำเป็น
*	Problem tracking 
*	เพื่อให้ผู้ใช้รายงานข้อผิดพลาดและปัญหาอื่น ๆ 
*	เพื่อให้นักพัฒนาซอฟต์แวร์ทั้งหมดสามารถดูว่าใครกำลังทำงานเกี่ยวกับปัญหาเหล่านี้และแก้ไขปัญหาเมื่อใด
Configuration management tool interaction
Host-target development
*	ซอฟต์แวร์ส่วนใหญ่ (แทบทั้งหมด) ได้รับการพัฒนาบนคอมพิวเตอร์หนึ่งเครื่อง (host) แต่ทำงานบนเครื่องอื่น ๆ (target)
*	โดยทั่วไปเรามักจะเรียกว่า development platform และ execution platform
*	platform ไม่ได้หมายถึงแค่ ฮาร์ดแวร์
*	platform ประกอบด้วยระบบปฏิบัติการที่ติดตั้งไว้พร้อมทั้งซอฟต์แวร์สนับสนุนอื่น ๆ เช่น database management system, development platforms,  interactive development environment เป็นต้น
*	development platform มักจะมีซอฟท์แวร์ติดตั้งมากกว่า execution platform 
*	platform เหล่านี้อาจมีสถาปัตยกรรมที่แตกต่างกัน
Host-target development
Development platform tools
*	ระบบ Integrated compiler และการแก้ไขตามไวยากรณ์  (syntax-directed editing )
*	ช่วยให้สามารถสร้าง แก้ไข และคอมไพล์โค้ดได้
*	ระบบดีบักภาษา
*	เครื่องมือแก้ไขกราฟิก เช่น เครื่องมือเพื่อแก้ไข UML
*	เครื่องมือทดสอบเช่น Junit ที่สามารถรันชุดทดสอบในโปรแกรม version ใหม่ได้โดยอัตโนมัติ
*	เครื่องมือสนับสนุนโครงการที่ช่วยจัดระเบียบ code สำหรับ project ต่างๆ
Integrated development environments (IDEs)
*	เครื่องมือการพัฒนาซอฟต์แวร์มักถูกจัดกลุ่มเพื่อสร้างสภาพแวดล้อมการพัฒนาแบบรวม (IDE)
*	IDE คือชุดเครื่องมือซอฟต์แวร์ที่สนับสนุนด้านต่าง ๆ ของการพัฒนาซอฟต์แวร์
*	มักจะประกอบด้วย common framework และ user interface
*	IDEs ถูกสร้างขึ้นเพื่อสนับสนุนการพัฒนาในภาษาการเขียนโปรแกรมเฉพาะ
*	เช่น Java IDE อาจได้รับการพัฒนาขึ้นเป็นพิเศษ
*	หรืออาจเป็น  IDE ทั่ว ๆ ไป แล้วมีเครื่องมือสนับสนุนภาษาเฉพาะให้เลือกใช้ (เช่น eclipse, vscode)
Open source development
Open source development
*	การพัฒนา open source เป็นแนวทางในการพัฒนาซอฟต์แวร์ซึ่งมีการเผยแพร่ซอร์สโค้ดของระบบซอฟต์แวร์และเปิดโอกาสให้อาสาสมัครได้เข้าร่วมในกระบวนการพัฒนา
*	จุดเริ่มต้นเกิดจาก Free Software Foundation (www.fsf.org) ซึ่งสนับสนุนว่าซอร์สโค้ดไม่ควรเป็นกรรมสิทธิ์ แต่ควรมีให้ผู้ใช้สามารถตรวจสอบและแก้ไขได้ตามต้องการ
*	ซอฟต์แวร์ open source ขยายแนวคิดนี้โดยใช้อินเทอร์เน็ตเพื่อรับสมัครนักพัฒนาอาสาสมัครจำนวนมากขึ้น 
Open source systems
*	ผลิตภัณฑ์ open source ที่รู้จักกันดีคือระบบปฏิบัติการ Linux ซึ่งใช้กันอย่างแพร่หลายในฐานะระบบเซิร์ฟเวอร์และเป็นสภาพแวดล้อมเดสก์ท็อป
*	ผลิตภัณฑ์ open source  ที่สำคัญอื่น ๆ ได้แก่ Java, เว็บเซิร์ฟเวอร์ Apache และระบบจัดการฐานข้อมูล mySQL
Open source issues
*	ผลิตภัณฑ์ที่มีการพัฒนาควรใช้ส่วนประกอบ open source หรือไม่?
*	ควรใช้วิธี open source เพื่อการพัฒนาซอฟต์แวร์หรือไม่?
Open source business
*	มีบริษัทจำนวนมากขึ้นเรื่อย ๆ ที่กำลังใช้แนวทาง open source ในการพัฒนา
*	รูปแบบธุรกิจของพวกเขาไม่ได้ขึ้นอยู่กับการขายผลิตภัณฑ์ซอฟต์แวร์ 
*	แต่ขายการ support ผลิตภัณฑ์นั้น
*	พวกเขาเชื่อว่าการมีส่วนร่วมของชุมชน open source จะช่วยให้ซอฟต์แวร์สามารถพัฒนาได้อย่างรวดเร็ว
*	จะสร้างชุมชนของผู้ใช้ซอฟต์แวร์ได้เร็วยิ่งขึ้น
*	จะขายการ support ได้มากขึ้น
Open source licensing
*	หลักการพื้นฐานของการพัฒนา open source คือซอร์สโค้ดควรมีอิสระในการใช้งาน
*	แต่ไม่ได้หมายความว่าทุกคนสามารถทุกย่างที่ต้องการกับซอร์สโค้ดนั้น
*	ตามกฎหมาย ผู้พัฒนา code (ทั้งบริษัทหรือบุคคล) ยังคงเป็นเจ้าของโค้ดอยู่ 
*	พวกเขาสามารถวางข้อจำกัดเกี่ยวกับวิธีการใช้ โดยการรวมเงื่อนไขที่มีผลผูกพันตามกฎหมายในใบอนุญาตซอฟต์แวร์ open source
*	นักพัฒนาซอฟต์แวร์ open source บางคนเชื่อว่าหากใช้ส่วนประกอบ open source ในการพัฒนาระบบใหม่ ระบบดังกล่าวควรเป็น open source ด้วย
*	นักพัฒนาซอฟต์แวร์บางคนยินดีที่จะอนุญาตให้ใช้ code ของตนโดยไม่มีข้อจำกัด
*	ซึ่งบางครั้งระบบที่พัฒนาแล้วอาจเป็นกรรมสิทธิ์และจำหน่ายในรูปแบบระบบปิด
License models
*	GNU General Public License (GPL) 
*	หรือใบอนุญาตที่เรียกว่า 'reciprocal' ซึ่งหมายความว่าหากเราใช้ซอฟต์แวร์ open source ที่ได้รับอนุญาตภายใต้ใบอนุญาต GPL เราต้องทำซอฟต์แวร์นั้นให้เป็น open source ด้วย 
*	GNU Lesser General Public License (LGPL) 
*	เป็นรูปแบบใบอนุญาต GPL ที่เราสามารถเขียน code ที่เชื่อมโยงไปยัง open source โดยไม่ต้องเผยแพร่แหล่งที่มาของ component เหล่านั้น
*	ใบอนุญาตจัดจำหน่ายมาตรฐาน Berkley (BSD) 
*	เป็นใบอนุญาตแบบ non-reciprocal  ซึ่งหมายความว่า ไม่จำเป็นต้องเผยแพร่การเปลี่ยนแปลงหรือแก้ไขใด ๆ ที่ทำกับ open source  
*	สามารถใช้ code ในระบบที่เป็นกรรมสิทธิ์ที่ขายได้
License management
*	สร้างระบบ เพื่อดูแลรักษาข้อมูลเกี่ยวกับส่วนประกอบ open source ที่ดาวน์โหลดและใช้
*	ศึกษาถึงใบอนุญาตประเภทต่าง ๆ และทำความเข้าใจว่า component ที่ได้รับอนุญาตมีการใช้งานอย่างไร
*	ระวังเส้นทางการพัฒนาของส่วนประกอบต่างๆ
*	ให้ความรู้บุคคลต่าง ๆ เกี่ยวกับ open source 
*	ให้มีการตรวจสอบระบบได้ ว่ามี open source อยู่หรือไม่
*	มีส่วนร่วมในชุมชน open source 








Key points
*	การออกแบบและการใช้งานซอฟต์แวร์เป็นกิจกรรมที่เกี่ยวเนื่องกัน 
*	ระดับของรายละเอียดในการออกแบบขึ้นอยู่กับประเภทของระบบ ไม่ว่าจะใช้วิธีการใด เช่น plan-driven หรือ agile
*	กระบวนการของการออกแบบเชิงวัตถุ ประกอบด้วยกิจกรรมในการออกแบบสถาปัตยกรรมระบบ, การระบุออบเจ็กต์ในระบบ, การอธิบายการออกแบบโดยใช้โมเดลวัตถุที่แตกต่างกัน และการจัดทำเอกสารอธิบายการรวมระบบ
*	กระบวนการออกแบบเชิงวัตถุ ทำให้เกิดแบบจำลองที่หลากหลาย เช่น 
*	โมเดลแบบ static (ได้แก่ class model, generalization models, association models) 
*	โมเดลแบบ dynamic (ได้แก่ sequence models, state machine models)
*	ต้องมีการกำหนดวิธีการใช้งานหรือการเชื่อมต่อของ object ต่างๆ อย่างแม่นยำเพื่อให้ object อื่น ๆ สามารถใช้งานมันได้ 
*	อาจนำ UML มาใช้เพื่ออธิบาย
Key points
*	เมื่อพัฒนาซอฟต์แวร์ ควรพิจารณาความเป็นไปได้ที่จะนำซอฟต์แวร์ที่มีอยู่มาใช้ใหม่
*	ไม่ว่าจะเป็น component, service, หรือระบบที่สมบูรณ์
*	Configuration management คือกระบวนการของการจัดการการเปลี่ยนแปลงในระบบซอฟต์แวร์ที่พัฒนาขึ้น 
*	เป็นสิ่งสำคัญเมื่อมีทีมงานร่วมมือกันพัฒนาซอฟต์แวร์
*	การพัฒนาซอฟต์แวร์ส่วนใหญ่เป็นการพัฒนาแบบ host-target development
*	คุณใช้ IDE บนเครื่องโฮสต์เพื่อพัฒนาซอฟต์แวร์ จากนั้นจะถูกโอนย้ายไปยังเครื่องเป้าหมายเพื่อการใช้งาน
*	การพัฒนา open source เกี่ยวข้องกับการทำให้ source code ของระบบเป็นแบบสาธารณะ 
*	ซึ่งหมายความว่าคนทั่วไปสามารถเสนอการเปลี่ยนแปลงและปรับปรุงซอฟต์แวร์
คำถาม???
